

different join syntaxes
case statements
regexp
self referencing query
exploding joins
coalesce
nvl

#########################
# NAVIGATING POSTGRESQL #
#########################

# list databases
\l 

# create database
create database tickit;

# connect to database
\c tickit


####################
# SET UP TEST DATA # 
####################

# create tables
create table users(
  userid integer not null,
  username char(8),
  firstname varchar(30),
  lastname varchar(30),
  city varchar(30),
  state char(2),
  email varchar(100),
  phone char(14),
  likesports varchar(1),
  liketheatre varchar(1),
  likeconcerts varchar(1),
  likejazz varchar(1),
  likeclassical varchar(1),
  likeopera varchar(1),
  likerock varchar(1),
  likevegas varchar(1),
  likebroadway varchar(1),
  likemusicals varchar(1));

create table venue(
  venueid smallint not null,
  venuename varchar(100),
  venuecity varchar(30),
  venuestate char(2),
  venueseats integer);

create table category(
  catid smallint not null,
  catgroup varchar(10),
  catname varchar(10),
  catdesc varchar(50));

create table date(
  dateid smallint not null,
  caldate date not null,
  day character(3) not null,
  week smallint not null,
  month character(5) not null,
  qtr character(5) not null,
  year smallint not null,
  holiday boolean default('N'));

create table event(
  eventid integer not null,
  venueid smallint not null,
  catid smallint not null,
  dateid smallint not null,
  eventname varchar(200),
  starttime timestamp);

create table listing(
  listid integer not null,
  sellerid integer not null,
  eventid integer not null,
  dateid smallint not null,
  numtickets smallint not null,
  priceperticket decimal(8,2),
  totalprice decimal(8,2),
  listtime timestamp);

create table sales(
  salesid integer not null,
  listid integer not null,
  sellerid integer not null,
  buyerid integer not null,
  eventid integer not null,
  dateid smallint not null,
  qtysold smallint not null,
  pricepaid decimal(8,2),
  commission decimal(8,2),
  saletime timestamp);


# load data from file into database using the 'copy' command
copy users from '{path to tickit data}/users.txt' delimiter '|';
copy venue from '{path to tickit data}/venue.txt' delimiter '|';
copy category from '{path to tickit data}/category.txt' delimiter '|';
copy date from '{path to tickit data}/date.txt' delimiter '|';
copy event from '{path to tickit data}/event.txt' delimiter '|';
copy listing from '{path to tickit data}/listing.txt' delimiter '|';
copy sales from '{path to tickit data}/sales.txt' delimiter '|';


# show all tables in database
# you should see 7 tables listed
\dt

# describe table
\d+ sales


##################
# SELECTING DATA #
##################

# SELECT
# select everything (*) from the category table
select * from category;

# use control-c to stop scrolling through the result set
select * from users;

# if you want to quickly see a few rows of data,
# then limit the number of rows
# this query statement also spans multiple lines
# end a statement with a semicolon (;) 
select * from users 
limit 10;

# you can also limit the number of columns returned in the results
# by explicitly selecting for the column names (instead of using *)
select userid, username, firstname, lastname, city, state, email, phone
from users
limit 10;

# SELECT WITH CONDITIONS

# select all columns from the sales table
# where quantity sold (qtysold) is equal to 1
# limit results to 10 rows
select * 
from sales
where qtysold = 1
limit 10;

# select the specified user fields from the users table
# where state = 'NY'
select userid, username, firstname, lastname, city, state, email, phone
from users
where state = 'NY';

# Similar to the above query, but now return rows 
# where state is either 'NY', 'CA', or 'OR'
select userid, username, firstname, lastname, city, state, email, phone
from users
where state in ('NY', 'CA', 'OR');


# CASE STATEMENTS
# note that I've also given a name to the column generated by the case statement (region)
select userid, username, firstname, lastname, city, state, email, phone,
  case
    when state in ('CA', 'OR', 'WA') then 'WEST COAST'
    when state in ('CT', 'ME', 'MA', 'NH', 'RI', 'VT') then 'NEW ENGLAND'
    else 'OTHER'
  end as region
from users
limit 50;


# DATE_PART

# create charts by different date dimensions
# dow is useful for segmenting time series data by day of week to account for fluctuations through the week 
select s.*, 
  date_part('year', s.saletime) as sale_year, 
  date_part('quarter', s.saletime) as sale_quarter, 
  date_part('month', s.saletime) as sale_month, 
  date_part('week', s.saletime) as sale_week, 
  date_part('dow', s.saletime) as sale_dow 
from sales s
limit 10;


# STRING MATCH AND REGEXP (REGULAR EXPRESSIONS)

# return entries that match a string pattern
# in this case, we want only users that have the 809 area code
select userid, username, firstname, lastname, city, state, email, phone
from users
where phone like '(809)%';

# create a new column containing only the area code for each user
select userid, username, firstname, lastname, city, state, email, phone,
  substring(phone from '\((.*)\)') as areacode
from users
limit 10;

###############
# AGGREGATION #
###############

# aggregation functions (count, sum, max, min)

# count total number of rows from the users table
select count(*) from users;

# you can also apply the count function to a single column
select count(state) from users;

# count distinct occurrences of states
select count(distinct state) from users;

# sum of quantity sold from the sales table
select sum(qtysold) from sales;

# sum of multiple columns
select sum(qtysold) as total_sold, sum(pricepaid) as total_sales_amount, sum(commission) as total_commission
from sales;

# select the highest single sale amount from the table
select max(pricepaid) from sales;

# select the lowest single sale amount from the table
select min(pricepaid) from sales;

# GROUP BY

# count number of users in each state
# and sort results by state in alphabetical order
select state, count(userid) as users
from users
group by state
order by state asc;

# count number of users in each state and city combination
select state, city, count(userid) as users
from users
group by state, city
order by count(userid) desc;

# use the column number short-cut to avoid typing out full column names
# 1 = 1st column, 2 = 2nd column, 3 = 3rd column, ... 
# this query is equivalent to the one above, but it's shorter,
# which is useful if you're grouping by many columns
select state, city, count(userid) as users
from users
group by 1,2
order by 3 desc;


# combine date_part with group by to compute total sales by month
select date_part('year', saletime) as year, 
      date_part('month', saletime) as month,
      count(salesid) as total_sales,
      sum(pricepaid) as total_sales_amount
from sales
group by 1,2;


# GROUP BY HAVING

select buyerid, count(salesid) as purchases
from sales
group by 1;

select buyerid, count(salesid) as purchases
from sales
group by 1
having count(salesid) = 1;

################################
# WORKING WITH MULTIPLE TABLES #
################################

# INNER JOIN SYNTAX
select s.*, e.*
from sales s, event e
where s.eventid = e.eventid
limit 5;

select s.*, e.*
from sales s inner join event e
on s.eventid = e.eventid
limit 10;;

select s.*, e.*, v.*
from sales s, event e, venue v
where s.eventid = e.eventid
  and e.venueid = v.venueid
limit 5;

select s.*, e.*, v.*
from sales s 
  inner join event e on s.eventid = e.eventid
  inner join venue v on e.venueid = v.venueid
limit 5;

# breakdown of ticket sales amount by state
# sorted by total_sales_amount in descending order
select v.venuestate, sum(s.pricepaid) as total_sales_amount
from sales s, event e, venue v
where s.eventid = e.eventid
  and e.venueid = v.venueid
group by 1
order by 2 desc;

select *
from sales s, listing l
where s.listid = l.listid
  and s.listid = 8942;

# 8512 distinct event ids
select count(distinct eventid) from sales;

# 8798 distinct event ids
select count(distinct eventid) from event;

# sort by sales in ascending order to see events with lowest sales
select e.eventid, e.eventname, count(s.*) as sales
from event e inner join sales s on e.eventid = s.eventid
group by 1,2
order by 3 asc;

# event is the "left" table that will be outer joined to sales
# all eventid/eventname combinations in the left (event) table
# will be returned regardless of whether it exists in the
# right (sales) table
select e.eventid, e.eventname, count(s.*) as sales
from event e left outer join sales s on e.eventid = s.eventid
group by 1,2
order by 3 asc;

# this query will produce only events that made no sales
select e.eventid, e.eventname, count(s.*) as sales
from event e left outer join sales s on e.eventid = s.eventid
group by 1,2
having count(s.*) = 0;

select e.eventid, e.eventname, count(s.*) as sales, sum(coalesce(s.pricepaid, 0)) as amount
from event e left join sales s on e.eventid = s.eventid
group by 1,2
order by 4 asc;


# SELF JOIN
select c1.catid, c1.catname, c2.catname as parentcatname
from category c1, category c2
where c1.parentid = c2.catid
  and c1.parentid is not null;

####################
# WINDOW FUNCTIONS #
####################

# return salesid, event id, pricepaid, and average transaction value for each event
select salesid, eventid, pricepaid, avg(pricepaid) over (partition by eventid)
from sales s;

# list each buyer's transaction in order
select s.*, rank() over (partition by s.buyerid order by s.saletime asc) as user_order_num
from sales s;

# query each buyer's first order
select p.* 
from (
  select s.*, rank() over (partition by s.buyerid order by s.saletime asc) as user_order_num
  from sales s
  ) p
where p.user_order_num = 1;

# query each buyer's last/most recent order
select p.* 
from (
  select s.*, rank() over (partition by s.buyerid order by s.saletime desc) as user_order_num
  from sales s
  ) p
where p.user_order_num = 1;